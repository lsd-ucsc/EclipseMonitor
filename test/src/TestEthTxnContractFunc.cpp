// Copyright (c) 2024 Haofan Zheng
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.


#include <gtest/gtest.h>

#include <EclipseMonitor/Eth/AbiWriter.hpp>
#include <EclipseMonitor/Eth/DataTypes.hpp>
#include <EclipseMonitor/Eth/Transaction/ContractFunction.hpp>
#include <EclipseMonitor/Exceptions.hpp>

#include <SimpleObjects/Codec/Hex.hpp>

#include "Common.hpp"


namespace EclipseMonitor_Test
{
	extern size_t g_numOfTestFile;
}

using namespace EclipseMonitor_Test;

using namespace EclipseMonitor::Eth;


static const ContractAddr gsk_testContractAddr = {
	// 0x09616C3d61b3331fc4109a9E41a8BDB7d9776609
	0x09U, 0x61U, 0x6CU, 0x3DU, 0x61U, 0xB3U, 0x33U, 0x1fU, 0xc4U, 0x10U,
	0x9aU, 0x9EU, 0x41U, 0xa8U, 0xBDU, 0xB7U, 0xd9U, 0x77U, 0x66U, 0x09U,
};


GTEST_TEST(TestEthTxnContractFunc, CountTestFile)
{
	static auto tmp = ++EclipseMonitor_Test::g_numOfTestFile;
	(void)tmp;
}


GTEST_TEST(TestEthTxnContractFunc, ContractFuncStaticDef_Construct)
{
	using namespace EclipseMonitor::Eth::Transaction;

	using AbiTupleWriter = AbiWriterStaticTuple<
		AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
		AbiWriterStaticTuple<
			AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
			AbiWriterStaticTuple<
				AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
				AbiWriter<SimpleObjects::ObjCategory::Bytes, std::true_type>
			>
		>,
		AbiWriter<SimpleObjects::ObjCategory::Bytes, AbiSize<5> >
	>;

	// Move Constructor
	{
		ContractFuncStaticDef<AbiTupleWriter> func(gsk_testContractAddr,"foo");

		EXPECT_EQ(func.GetContractAddr(), gsk_testContractAddr);
		EXPECT_EQ(func.GetFuncName(), "foo");
		EXPECT_EQ(func.GetAbiWriter().IsDynamicType(), true);

		ContractFuncStaticDef<AbiTupleWriter> func2(std::move(func));

		EXPECT_EQ(func2.GetContractAddr(), gsk_testContractAddr);
		EXPECT_EQ(func2.GetFuncName(), "foo");
		EXPECT_EQ(func2.GetAbiWriter().IsDynamicType(), true);
	}

	// Move assignment
	{
		ContractFuncStaticDef<AbiTupleWriter> func(gsk_testContractAddr,"foo");

		EXPECT_EQ(func.GetContractAddr(), gsk_testContractAddr);
		EXPECT_EQ(func.GetFuncName(), "foo");
		EXPECT_EQ(func.GetAbiWriter().IsDynamicType(), true);

		ContractFuncStaticDef<AbiTupleWriter> func2(ContractAddr(), "bar");

		EXPECT_EQ(func2.GetContractAddr(), ContractAddr());
		EXPECT_EQ(func2.GetFuncName(), "bar");
		EXPECT_EQ(func2.GetAbiWriter().IsDynamicType(), true);

		func2 = std::move(func);

		EXPECT_EQ(func2.GetContractAddr(), gsk_testContractAddr);
		EXPECT_EQ(func2.GetFuncName(), "foo");
		EXPECT_EQ(func2.GetAbiWriter().IsDynamicType(), true);
	}
}


GTEST_TEST(TestEthTxnContractFunc, ContractFuncStaticDef_CallByTxn)
{
	using namespace EclipseMonitor::Eth::Transaction;

	// static tuple
	{
		using AbiTupleWriter = AbiWriterStaticTuple<
			AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
			AbiWriterStaticTuple<
				AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
				AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>
			>,
			AbiWriter<SimpleObjects::ObjCategory::Bytes, AbiSize<5> >
		>;

		ContractFuncStaticDef<AbiTupleWriter> func(gsk_testContractAddr, "foo");

		EXPECT_EQ(func.GetContractAddr(), gsk_testContractAddr);
		EXPECT_EQ(func.GetFuncName(), "foo");
		EXPECT_EQ(func.GetAbiWriter().IsDynamicType(), false);

		auto val1 = SimpleObjects::UInt64(12345);
		auto val2 = SimpleObjects::UInt64(54321);
		auto val3 = SimpleObjects::UInt64(67890);
		auto val4 = SimpleObjects::Bytes({ 0x01U, 0x02U, 0x03U, 0x04U, 0x05U });

		const SimpleObjects::BaseObj& valRef1 = val1;
		const SimpleObjects::BaseObj& valRef2 = val2;
		const SimpleObjects::BaseObj& valRef3 = val3;
		const SimpleObjects::BaseObj& valRef4 = val4;

		auto txn = func.CallByTxn(
			valRef1,
			std::forward_as_tuple(valRef2, valRef3),
			valRef4
		);

		txn.SetChainID(1900);
		txn.SetNonce(34);
		txn.SetMaxPriorFeePerGas(2000000000);
		txn.SetMaxFeePerGas(2000000000);
		txn.SetGasLimit(100000);
		txn.SetAmount(0);

		std::vector<uint8_t> expectedSerialized = {
			0xf8U, 0xafU, 0x82U, 0x07U, 0x6cU, 0x22U, 0x84U, 0x77U, 0x35U, 0x94U, 0x00U, 0x84U, 0x77U, 0x35U, 0x94U, 0x00U,
			0x83U, 0x01U, 0x86U, 0xa0U, 0x94U, 0x09U, 0x61U, 0x6cU, 0x3dU, 0x61U, 0xb3U, 0x33U, 0x1fU, 0xc4U, 0x10U, 0x9aU,
			0x9eU, 0x41U, 0xa8U, 0xbdU, 0xb7U, 0xd9U, 0x77U, 0x66U, 0x09U, 0x80U, 0xb8U, 0x84U, 0xfaU, 0x81U, 0xb4U, 0x25U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x30U, 0x39U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0xd4U, 0x31U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x01U, 0x09U, 0x32U,
			0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0xc0U,
		};

		auto rlp = txn.RlpSerialize();
		EXPECT_EQ(rlp, expectedSerialized);

		std::array<uint8_t, 32> expHash = {
			// fabb5744e518f43d7ad6629736639020594076dcf1cb155ac374f4854614b086
			0xfaU, 0xbbU, 0x57U, 0x44U, 0xe5U, 0x18U, 0xf4U, 0x3dU, 0x7aU, 0xd6U, 0x62U, 0x97U, 0x36U, 0x63U, 0x90U, 0x20U,
			0x59U, 0x40U, 0x76U, 0xdcU, 0xf1U, 0xcbU, 0x15U, 0x5aU, 0xc3U, 0x74U, 0xf4U, 0x85U, 0x46U, 0x14U, 0xb0U, 0x86U,
		};
		auto rlpHash = txn.Hash();
		EXPECT_EQ(expHash, rlpHash);
	}

	// dynamic tuple
	{
		using AbiTupleWriter = AbiWriterStaticTuple<
			AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
			AbiWriterStaticTuple<
				AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
				AbiWriterStaticTuple<
					AbiWriter<SimpleObjects::ObjCategory::Integer, AbiUInt64>,
					AbiWriter<SimpleObjects::ObjCategory::Bytes, std::true_type>
				>
			>,
			AbiWriter<SimpleObjects::ObjCategory::Bytes, AbiSize<5> >
		>;

		ContractFuncStaticDef<AbiTupleWriter> func(gsk_testContractAddr, "bar");

		EXPECT_EQ(func.GetContractAddr(), gsk_testContractAddr);
		EXPECT_EQ(func.GetFuncName(), "bar");
		EXPECT_EQ(func.GetAbiWriter().IsDynamicType(), true);

		auto val1 = SimpleObjects::UInt64(12345);
		auto val2 = SimpleObjects::UInt64(54321);
		auto val3 = SimpleObjects::UInt64(67890);
		auto val4 = SimpleObjects::Bytes({ 0x01U, 0x02U, 0x03U, 0x04U, 0x05U });

		const SimpleObjects::BaseObj& valRef1 = val1;
		const SimpleObjects::BaseObj& valRef2 = val2;
		const SimpleObjects::BaseObj& valRef3 = val3;
		const SimpleObjects::BaseObj& valRef4 = val4;

		auto txn = func.CallByTxn(
			valRef1,
			std::forward_as_tuple(
				valRef2,
				std::forward_as_tuple(valRef3, valRef4)
			),
			valRef4
		);

		txn.SetChainID(1900);
		txn.SetNonce(34);
		txn.SetMaxPriorFeePerGas(2000000000);
		txn.SetMaxFeePerGas(2000000000);
		txn.SetGasLimit(100000);
		txn.SetAmount(1000);

		std::vector<uint8_t> expectedSerialized = {
			0xf9U, 0x01U, 0x52U, 0x82U, 0x07U, 0x6cU, 0x22U, 0x84U, 0x77U, 0x35U, 0x94U, 0x00U, 0x84U, 0x77U, 0x35U, 0x94U,
			0x00U, 0x83U, 0x01U, 0x86U, 0xa0U, 0x94U, 0x09U, 0x61U, 0x6cU, 0x3dU, 0x61U, 0xb3U, 0x33U, 0x1fU, 0xc4U, 0x10U,
			0x9aU, 0x9eU, 0x41U, 0xa8U, 0xbdU, 0xb7U, 0xd9U, 0x77U, 0x66U, 0x09U, 0x82U, 0x03U, 0xe8U, 0xb9U, 0x01U, 0x24U,
			0xf4U, 0xdcU, 0x33U, 0x21U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x30U, 0x39U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x60U, 0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0xd4U, 0x31U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x40U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x01U, 0x09U, 0x32U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x40U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x05U, 0x01U, 0x02U, 0x03U, 0x04U, 0x05U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U,
			0x00U, 0x00U, 0x00U, 0x00U, 0xc0U,
		};

		auto rlp = txn.RlpSerialize();
		EXPECT_EQ(rlp, expectedSerialized);

		std::array<uint8_t, 32> expHash = {
			// 7bf04215d5bc74809640a0ecd111c55e7d07ed14e4db4c6e82036d2ce890542e
			0x7bU, 0xf0U, 0x42U, 0x15U, 0xd5U, 0xbcU, 0x74U, 0x80U, 0x96U, 0x40U, 0xa0U, 0xecU, 0xd1U, 0x11U, 0xc5U, 0x5eU,
			0x7dU, 0x07U, 0xedU, 0x14U, 0xe4U, 0xdbU, 0x4cU, 0x6eU, 0x82U, 0x03U, 0x6dU, 0x2cU, 0xe8U, 0x90U, 0x54U, 0x2eU,
		};
		auto rlpHash = txn.Hash();
		EXPECT_EQ(expHash, rlpHash);
	}
}

